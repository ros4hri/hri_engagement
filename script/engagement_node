#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from __future__ import absolute_import
import rospy
from hri_msgs.msg import IdsList
from hri_msgs.msg import EngagementLevel
from cv_bridge import CvBridge
from sensor_msgs.msg import RegionOfInterest
from std_msgs.msg import String
import tf

import numpy as np
from enum import Enum



class EngagementNode(object):
    def __init__(self,
                 robot_head_frame,
                 distance_thr=1.5,
                 gaze_distance_scale_thr=0.5):
        """
        :param robot_head_frame: frame of the robot head
        :param distance_thr: max distance used by the robot to look for active users
        :param gaze_distance_scale_thr: value used to define the FoV of the agents (either a human or robot)
        """
        self.br = CvBridge()
        self.faces_list_sub = rospy.Subscriber(
            "/humans/faces/tracked",
            IdsList,
            self.face_list_cb)

        self.listener = tf.TransformListener()
        # to change on the robot
        self.base_link = robot_head_frame

        # IdsList of face detected (ids, header)
        self.face_detected = IdsList()

        # distance threshold for considering faces
        self.distance_thr = distance_thr
        # Scaling factor for the gaze distance
        self.gaze_distance_scale_thr = gaze_distance_scale_thr

        # frame rate of the node
        self.frame_rate = 5
        # time for engagement history
        self.buffer_time = 5
        # number of samples used to infer the user's engagement
        self.engagement_history_size = self.frame_rate * self.buffer_time

        # engagement level of a human. Key:face_id, Value: list, i.e., engagement_buffer
        self.humans_engagement_history = dict()
        # current engagement level of the active humans. Key:face_id, Value: ["engaged"],
        # ["disengaged"], ["engaging"]
        self.humans_current_engagement_level = dict()

        self.active_humans = list()
        self.loop_rate = rospy.Rate(5)

    def face_list_cb(self, msg):
        """ Callback that updates the face_detected list
             msg: IdList that consists of ids and header """
        self.face_detected = msg

    def get_active_humans(self):
        """ Checking for faces closer than self.faces_distance_thr"""

        for face_id in self.face_detected.ids:
            # for each active human we initialise the engagement history vector
            if face_id not in self.humans_engagement_history:
                self.humans_engagement_history[face_id] = [0]
                self.humans_current_engagement_level[face_id] = EngagementLevel.DISENGAGED
            try:
                # transform from base link to gaze_[face_id]
                self.listener.waitForTransform(
                    self.base_link,
                    "gaze_" + face_id,
                    rospy.Time(0),
                    rospy.Duration(4.0))
                gaze_origin, _ = self.listener.lookupTransform(
                    self.base_link,
                    "gaze_" + face_id,
                    rospy.Time(0))

                face_distance = np.sqrt(gaze_origin[0] ** 2
                                        + gaze_origin[1] ** 2
                                        + gaze_origin[2] ** 2)

                if face_distance < self.distance_thr and \
                        face_id not in list(map(lambda x: x[0], self.active_humans)):
                    self.active_humans.append((face_id, rospy.Time.now(), face_distance))

            except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException):
                continue

    def compute_engagement(self, face_id):
        """here we need to compute the engagement level of each active human
        the level is assigned to "disengaged",  "engaging", "engaged", "disengaging"
        depending on the average value memorised in the engagement_buffer for
        each human
        At the beginning all the active humans are disengaged
        """

        # waiting a few frames before assessing whether a person is engaged or not
        if len(self.humans_engagement_history[face_id]) < self.engagement_history_size:
            rospy.loginfo("waiting {} for human {} to engage with the robot".
                          format(self.humans_engagement_history[face_id], face_id))
        else:
            self.humans_engagement_history[face_id] = \
                self.humans_engagement_history[face_id][-self.engagement_history_size:]
            #compute the average engagement value
            engagement_value = sum(self.humans_engagement_history[face_id][-self.engagement_history_size:]) \
                               / self.engagement_history_size

            if self.humans_current_engagement_level[face_id] == EngagementLevel.DISENGAGED:
                if -1 <= engagement_value < -0.5:
                    self.humans_current_engagement_level[face_id] = EngagementLevel.DISENGAGED
                else:
                    self.humans_current_engagement_level[face_id] = EngagementLevel.ENGAGING

            elif self.humans_current_engagement_level[face_id] == EngagementLevel.ENGAGING:
                if -1 <= engagement_value < -0.5:
                    self.humans_current_engagement_level[face_id] = EngagementLevel.DISENGAGED
                elif -0.5 <= engagement_value < 0.0:
                    self.humans_current_engagement_level[face_id] = EngagementLevel.ENGAGING
                else:
                    self.humans_current_engagement_level[face_id] = EngagementLevel.ENGAGED

            elif self.humans_current_engagement_level[face_id] == EngagementLevel.ENGAGED:
                if engagement_value > 0.0:
                    self.humans_current_engagement_level[face_id] == EngagementLevel.ENGAGED
                elif engagement_value <= 0.0:
                    self.humans_current_engagement_level[face_id] = EngagementLevel.DISENGAGING

            elif self.humans_current_engagement_level[face_id] == EngagementLevel.DISENGAGING:
                if engagement_value > 0.0:
                    self.humans_current_engagement_level[face_id] == EngagementLevel.ENGAGED
                elif engagement_value <= 0.0:
                    self.humans_current_engagement_level[face_id] = EngagementLevel.DISENGAGED

            rospy.loginfo("Engagement status for {} is: {}".
                          format(face_id, self.humans_current_engagement_level[face_id]))


    def get_engaged_humans(self):
        """ Checking for humans who are active and update their engagement state
         at the robot faces """
        for face in self.active_humans:
            try:
                # transform from gaze_[face_id] to base_link
                self.listener.waitForTransform(
                    "gaze_" + face[0],
                    self.base_link,
                    rospy.Time(0),
                    rospy.Duration(4.0))
                gaze_origin_inverse, _ = self.listener.lookupTransform(
                    "gaze_" + face[0],
                    self.base_link,
                    rospy.Time(0))
                # check on the same vector expressed in gaze_<id> frame,
                # evaluating the length of its projection
                # on the XY plane.
                gaze_distance = np.sqrt(gaze_origin_inverse[0] ** 2
                                        + gaze_origin_inverse[1] ** 2)

                if gaze_distance < \
                        (self.gaze_distance_scale_thr * gaze_origin_inverse[2]):
                    self.humans_engagement_history[face[0]].append(1)
                else:
                    # the human is currently disengaged, it might have just lost their engagement,
                    # or they are in this state since a while
                    # check human previous history
                    self.humans_engagement_history[face[0]].append(-1)

                self.compute_engagement(face[0])

            except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException):
                continue

    def send_engaged_status(self):
        """Publish the IdsList of the active humans"""

        for face_id, engagement_status in self.humans_current_engagement_level.items():
            # N.B: <face_id> needs to be replace with <person_id>
            engaged_humans_pub = rospy.Publisher(
                "/humans/persons/" + face_id + "/engagement_status",
                EngagementLevel,
                queue_size=1)
            engagement_msg = EngagementLevel()
            engagement_msg.level = engagement_status
            #rospy.loginfo("Engagement status for {} is: {}".format(face_id, engagement_status))
            engaged_humans_pub.publish(engagement_status)

    def run(self):
        while not rospy.is_shutdown():
            self.get_active_humans()
            self.get_engaged_humans()
            self.send_engaged_status()


if __name__ == "__main__":
    rospy.init_node("engagement_node")
    robot_head_frame = rospy.get_param("~robot_head_frame", "head_2_link")
    node = EngagementNode(
        robot_head_frame=robot_head_frame)
    node.run()
