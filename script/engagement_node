#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from __future__ import absolute_import
import rospy
from geometry_msgs.msg import PointStamped
from hri_msgs.msg import IdsList

from hri_msgs.msg import Expression
from expressive_eyes.face_manager import FaceManager
from expressive_eyes import expressions as exp
from sensor_msgs.msg import Image
from cv_bridge import CvBridge
import cv2
import actionlib
import hri_msgs.msg
import tf
import numpy as np


class EngagementNode(object):
    def __init__(self):
        self.br = CvBridge()
        """ Initialize the goal publisher node."""
        self.look_at_pub = rospy.Publisher('/look_at', PointStamped,
                                          queue_size=10)

        self.faces_list_sub = rospy.Subscriber(
            "/humans/faces/tracked", 
            IdsList, 
            self.face_list_cb)
        self.listener = tf.TransformListener()

        self.face_detected = []

        self.loop_rate = rospy.Rate(30)

        self.active_id = ""
        self.face_detected_time = rospy.Time.now()
        
        self.state = 0
        self.close_faces = []
        self.base_link = "camera_link" # to change on the robot
        ### To set as __init__ param ###
        self.distance_threshold = 1.5 # distance threshold for considering faces
        self.time_threshold = 5.0 # time threshold for the retrieval of a face when lost
        self.distance_last_position_threshold = 0.3
        self.gaze_distance_threshold_scale = 0.5 # Scaling factor for the gaze distance
        ################################
        self.last_position = PointStamped() # last position of the lost engaged face

        self.closest_face = ()

        self.active_users = IdsList()
        self.active_users_pub = rospy.Publisher(
            "/active_users",
            IdsList,
            queue_size=1)

    def face_list_cb(self, msg):
        self.face_detected = msg.ids
        self.face_detected_time = msg.header.stamp

    def get_close_faces(self):
        # checking for faces closer than face distance threshold
        self.close_faces = []
        for face_id in self.face_detected:
            try:
                self.listener.waitForTransform(
                    self.base_link, 
                    "gaze"+face_id, 
                    rospy.Time(0), 
                    rospy.Duration(4.0))
                gaze_origin, _  = self.listener.lookupTransform(
                    self.base_link, 
                    "gaze"+face_id, 
                    rospy.Time(0))
                gaze_origin_inverse, _ = self.listener.lookupTransform(
                    "gaze"+face_id,
                    self.base_link, 
                    rospy.Time(0))
                # gaze_origin = origin of the gaze<id> frame in base_link frame
                # We also need to get information about the gaze direction
                # to do this, we can check on the same vector expressed in
                # gaze<id> frame, evaluating the length of its projection 
                # on the XY plane.
                face_distance = np.sqrt(gaze_origin[0]**2 \
                                        + gaze_origin[1]**2 \
                                        + gaze_origin[2]**2)
                gaze_distance = np.sqrt(gaze_origin_inverse[0]**2 \
                                        + gaze_origin_inverse[1]**2)
                if face_distance < self.distance_threshold \
                   and gaze_distance < (self.gaze_distance_threshold_scale*face_distance):
                    self.close_faces.append(
                        (face_id, gaze_distance, gaze_origin))
            except tf.Exception: # here it should be transform exception
                rospy.logwarn("Missing frame %s, skipping upload", "gaze"+face_id)

    def get_closest_face(self):
        min_distance = 1.5
        self.closest_face = ()
        if len(self.close_faces) == 1:
            self.closest_face = self.close_faces[0]
        else:
            for face_tuple in self.close_faces:
                print(face_tuple)
                if face_tuple[1] < min_distance:
                    min_distance = face_tuple[1]
                    self.closest_face = face_tuple

    def check_for_egagement(self):

        '''state machine 
        0 no engagement
        1 engaged
        2 retriving engagement
        '''

        if self.state == 0:
            # The robot has no trace of a person engaged
            # and looks for new people engaged
            if len(self.face_detected) > 0:
                self.get_close_faces()
                if len(self.close_faces) > 0:
                    self.get_closest_face()
                    print('closest face:', self.closest_face)
                    self.active_id = self.closest_face[0]
                    self.state = 1
                    self.last_position = self.closest_face[2] 

        if self.state == 1:
            # We check if the person registered as engaged
            # is still registered as a close face
            self.get_close_faces()
            if len(self.close_faces) == 0:
                self.state = 2
                self.retrieve_starting_time = rospy.Time.now()
            else:
                found = False
                for face_tuple in self.close_faces:
                    if self.active_id == face_tuple[0]:
                        found = True
                        self.last_position = face_tuple[2] 
                        break
                if found:
                    point = PointStamped()
                    point.header.stamp = self.face_detected_time
                    point.header.frame_id = "gaze"+self.active_id
                    point.point.x = 0
                    point.point.y = 0
                    point.point.z = 0
                    self.look_at_pub.publish(point)
                else:
                    self.active_id = ""
                    self.state = 2
                    self.retrieve_starting_time = rospy.Time.now()

        if self.state == 2:
            time_from_last_seen = \
                (rospy.Time.now() - self.retrieve_starting_time).to_sec()
            if time_from_last_seen < self.time_threshold:
                print('Looking for a face close to the last one')
                self.get_close_faces()
                if len(self.close_faces) > 0:
                    for face_tuple in self.close_faces:
                        distance_from_last_position = \
                            np.sqrt((face_tuple[2][0]-self.last_position[0])**2 \
                                + (face_tuple[2][1]-self.last_position[1])**2 \
                                + (face_tuple[2][2]-self.last_position[2])**2)
                        if distance_from_last_position \
                           < self.distance_last_position_threshold:
                            self.active_id = face_tuple[0]
                            self.state = 1
                            print('Found a face close to the last one')
                            print(face_tuple)
                            break
            else:
                print('Not found a face close to the last one: go to state 0')
                self.state = 0

    def send_active_users(self):

        self.active_users.ids = []

        for face_tuple in self.close_faces:
            self.active_users.ids.append(face_tuple[0])

        self.active_users.header.stamp = rospy.Time.now()
        self.active_users_pub.publish(self.active_users)                

    def run(self):

        elapsed_time = rospy.Duration()

        while not rospy.is_shutdown():
            begin_time = rospy.Time.now()
            #execute our code here

            self.check_for_egagement()
            self.send_active_users()

            self.loop_rate.sleep()

            elapsed_time = rospy.Time.now() - begin_time


if __name__ == "__main__":
    rospy.init_node("engagement_node")
    node = EngagementNode()
    node.run()
