#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from __future__ import absolute_import
import rospy
from hri_msgs.msg import IdsList
from hri_msgs.msg import EngagementLevel
from cv_bridge import CvBridge
from std_msgs.msg import String
import tf

import numpy as np
import enum


class EngagementStatus(enum.Enum):
    """
    Auxiliary class to print in a more intuitive way the engagement status
    """
    # unknown: no information is provided about the engagement level
    UNKNOWN = 0
    # disengaged: the human has not looked in the direction of the robot
    DISENGAGED = 1
    # engaging: the human has started to look in the direction of the robot
    ENGAGING = 2
    # engaged: the human is fully engaged with the robot
    ENGAGED = 3
    # disengaging: the human has started to look away from the robot
    DISENGAGING = 4


class EngagementNode(object):
    """
    This node detects the engagement status of the active humans and
    publish it on /humans/persons/<human_id>/engagement_status
    # tracked humans are those who are known and currently tracked
    # active humans are those who are known, currently tracked
    and in the engagement zone
    (distance from the robot < zone distance_thr)
    """

    def __init__(self,
                 robot_head_frame,
                 engagement_status_pb_rate,
                 distance_thr=1.5,
                 gaze_distance_scale_thr=0.5):
        """
        :param robot_head_frame: -> str
        frame of the robot head
        :param engagement_status_pb_rate -> Int
        publishing rate of the human engagement status
        :param distance_thr: -> float
        max distance used by the robot to look for active users
        :param gaze_distance_scale_thr: -> float
        value used to define the FoV of the agents (either a human or robot)
        """
        self.br = CvBridge()
        self.listener = tf.TransformListener()
        # to change on the robot
        self.base_link = robot_head_frame

        # distance threshold for considering faces
        self.distance_thr = distance_thr
        # Scaling factor for the gaze distance
        self.gaze_distance_scale_thr = gaze_distance_scale_thr

        # frame rate of the node
        self.frame_rate = 30
        # time for engagement history
        self.buffer_time = 2
        # number of samples used to infer the user's engagement
        self.engagement_history_size = self.frame_rate * self.buffer_time

        # engagement level of a human.
        # Key:face_id, Value: list, i.e., engagement_buffer
        self.humans_engagement_history = dict()
        # current engagement status of the active humans.
        # Key:face_id, Value: e.g., "engaged",
        self.humans_current_engagement_level = dict()

        # those humans who are actively detected
        self.tracked_humans_in_the_scene = IdsList()
        # those humans who are actively detected and at a distance
        # less than self.distance_thr
        self.active_humans = list()

        # for the current version in order to compute engagement
        # we need to get the transformation from the gaze_id published
        # as tf by the hri_face_detection
        self.face_id = ""

        # timers callback
        self.rate = 30
        self.timer_run = rospy.Timer(rospy.Duration(1 / self.rate), self.run)
        self.timer_pub = rospy.Timer(rospy.Duration(1 / engagement_status_pb_rate),
                                     self.send_engaged_status)

    def tracked_human_list_cb(self, msg):
        """ Callback that updates the detected persons
             :param msg: -> IdList
             ids and header of the tracked humans """
        self.tracked_humans_in_the_scene = msg


    def get_active_humans(self):
        """ Checking for tracked persons closer than self.distance_thr"""

        self.tracked_humans_in_the_scene = rospy.wait_for_message("/humans/persons/tracked",
                                                                  IdsList, timeout=1)

        current_face_id = None

        for human_id in self.tracked_humans_in_the_scene.ids:
            # for each active human we initialise the engagement history vector
            if human_id not in self.humans_engagement_history:
                self.humans_engagement_history[human_id] = [0]
                self.humans_current_engagement_level[human_id] \
                    = EngagementLevel.DISENGAGED
            try:
                # read the current face_id of the humans
                current_face_id = rospy.wait_for_message("/humans/persons/"
                                                      + human_id + "/face_id",
                                                      String, timeout=1)

                # transform from base link to gaze_[face_id]
                self.listener.waitForTransform(
                    self.base_link,
                    "gaze_" + current_face_id.data,
                    rospy.Time(0),
                    rospy.Duration(4.0))

                gaze_origin, _ = self.listener.lookupTransform(
                    self.base_link,
                    "gaze_" + current_face_id.data,
                    rospy.Time(0))

                face_distance = np.sqrt(gaze_origin[0] ** 2
                                        + gaze_origin[1] ** 2
                                        + gaze_origin[2] ** 2)

                if face_distance < self.distance_thr and \
                        human_id not in list(map(lambda x: x[0],
                                                 self.active_humans)):
                    self.active_humans.append((human_id, rospy.Time.now(),
                                               face_distance))

            except tf.Exception:
                # here it should be transform exception
                rospy.logwarn("Unable to find a transform"
                              " between frames %s and gaze_%s"
                              "Can not compute active human %s",
                              self.base_link, current_face_id.data,  human_id)

    def compute_engagement(self, human_id):
        """ Computes the engagement level of each active human
        the status of each human can be "unknown", "disengaged", "engaging",
        "engaged", "disengaging", depending on the average value stored in
        the engagement_buffer for each human.
        At the beginning all the active humans are disengaged

        :param human_id :-> str
        the id of the human for whom we check the engagement status
        """

        # waiting a few frames before assessing whether a person is engaged or not
        if len(self.humans_engagement_history[human_id]) \
                < self.engagement_history_size:
            rospy.loginfo("building buffer for human {}".format(human_id))
        else:
            # clean up the buffer
            self.humans_engagement_history[human_id] = \
                self.humans_engagement_history[human_id][-self.engagement_history_size:]

            # compute the average engagement value
            engagement_value = sum(self.humans_engagement_history[human_id]
                                   [-self.engagement_history_size:]) \
                               / self.engagement_history_size

            if self.humans_current_engagement_level[human_id] \
                    == EngagementLevel.DISENGAGED:
                if -1 <= engagement_value < 0:
                    self.humans_current_engagement_level[human_id] \
                        = EngagementLevel.DISENGAGED
                else:
                    self.humans_current_engagement_level[human_id] \
                        = EngagementLevel.ENGAGING

            elif self.humans_current_engagement_level[human_id] \
                    == EngagementLevel.ENGAGING:
                if -1 <= engagement_value < -0.5:
                    self.humans_current_engagement_level[human_id] \
                        = EngagementLevel.DISENGAGED
                elif -0.5 <= engagement_value < 0.0:
                    self.humans_current_engagement_level[human_id] \
                        = EngagementLevel.ENGAGING
                else:
                    self.humans_current_engagement_level[human_id] \
                        = EngagementLevel.ENGAGED

            elif self.humans_current_engagement_level[human_id] \
                    == EngagementLevel.ENGAGED:
                if engagement_value > 0.0:
                    self.humans_current_engagement_level[human_id] \
                        = EngagementLevel.ENGAGED
                elif engagement_value <= 0.0:
                    self.humans_current_engagement_level[human_id] \
                        = EngagementLevel.DISENGAGING

            elif self.humans_current_engagement_level[human_id] \
                    == EngagementLevel.DISENGAGING:
                if engagement_value > 0.0:
                    self.humans_current_engagement_level[human_id] \
                        = EngagementLevel.ENGAGED
                elif engagement_value <= 0.0:
                    self.humans_current_engagement_level[human_id] \
                        = EngagementLevel.DISENGAGED

        rospy.loginfo("Engagement status for {} is: {}".format(
            human_id,
            EngagementStatus(self.humans_current_engagement_level[human_id])))

    def get_engaged_humans(self):
        """ it checks for humans who are active and updates
        their engagement status """

        # each entry of active_humans is a tuple as follows
        # (human_id, rospy.Time.now(), face_distance)
        current_face_id = None

        for human in self.active_humans:
            try:
                current_face_id = rospy.wait_for_message("/humans/persons/"
                                                         + human[0] + "/face_id",
                                                         String, timeout=1)

                # transform from gaze_[human_id] to base_link
                self.listener.waitForTransform(
                    "gaze_" + current_face_id.data,
                    self.base_link,
                    rospy.Time(0),
                    rospy.Duration(4.0))
                gaze_origin_inverse, _ = self.listener.lookupTransform(
                    "gaze_" + current_face_id.data,
                    self.base_link,
                    rospy.Time(0))
                # check on the same vector expressed in gaze_<id> frame,
                # evaluating the length of its projection
                # on the XY plane.
                gaze_distance = np.sqrt(gaze_origin_inverse[0] ** 2
                                        + gaze_origin_inverse[1] ** 2)
                # the human is currently engaged
                if gaze_distance < \
                        (self.gaze_distance_scale_thr * gaze_origin_inverse[2]):
                    self.humans_engagement_history[human[0]].append(1)
                else:
                    # the human is currently disengaged
                    self.humans_engagement_history[human[0]].append(-1)

                self.compute_engagement(human[0])

            except tf.Exception:
                # here it should be transform exception
                rospy.logwarn("Unable to find a transform"
                              " between frames gaze_%s and %s. "
                              "Can not compute engagement status for human %s",
                              current_face_id.data, self.base_link, human[0])

    def send_engaged_status(self, event=None):
        """ Timer callback to publish the IdsList of the engaged humans
        according to timer set in the constructor """

        for human_id, engagement_status in \
                self.humans_current_engagement_level.items():
            engaged_humans_pub = rospy.Publisher(
                "/humans/persons/" + human_id + "/engagement_status",
                EngagementLevel,
                queue_size=10)
            engagement_msg = EngagementLevel()
            engagement_msg.level = engagement_status
            engaged_humans_pub.publish(engagement_msg)

    def run(self, event=None):
        """ Timer callback to loop for the active humans and compute
         their engagement status according to timer set in the constructor """
        self.get_active_humans()
        self.get_engaged_humans()


if __name__ == "__main__":
    rospy.init_node("engagement_node")
    robot_head_frame = rospy.get_param("~robot_head_frame", "head_2_link")
    engagement_status_pb_rate = rospy.get_param(param_name="~engagement_status_pb_rate", default=10)
    node = EngagementNode(
        robot_head_frame=robot_head_frame,
        engagement_status_pb_rate=engagement_status_pb_rate)
    rospy.spin()
